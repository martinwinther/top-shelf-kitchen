---
import { getCollection } from 'astro:content';
import SiteLayout from '../../layouts/SiteLayout.astro';
import RecipeCard from '../../components/recipes/RecipeCard.astro';
import { RecipeFilters } from '../../components/react/RecipeFilters';
import { getPublishedRecipes, getRecipeSlug } from '../../lib/recipes';

const publishedRecipes = await getPublishedRecipes();

// Derive categories from schema (known list)
const categories = ['breakfast', 'lunch', 'dinner', 'dessert', 'snacks'] as const;

// Derive unique cuisines from recipes, sorted
const cuisines = Array.from(
  new Set(publishedRecipes.map((recipe) => recipe.data.cuisine))
).sort();

// Read query params
const searchParams = Astro.url.searchParams;
const filterCategory = searchParams.get('category') || '';
const filterCuisine = searchParams.get('cuisine') || '';
const sortBy = searchParams.get('sort') || 'newest';

// Filter recipes
let visibleRecipes = publishedRecipes;

if (filterCategory) {
  visibleRecipes = visibleRecipes.filter(
    (recipe) => recipe.data.category === filterCategory
  );
}

if (filterCuisine) {
  visibleRecipes = visibleRecipes.filter(
    (recipe) => recipe.data.cuisine === filterCuisine
  );
}

// Sort recipes
visibleRecipes = [...visibleRecipes].sort((a, b) => {
  if (sortBy === 'title') {
    return a.data.title.localeCompare(b.data.title);
  }
  
  if (sortBy === 'quickest') {
    const totalA = a.data.times.prepMinutes + a.data.times.cookMinutes;
    const totalB = b.data.times.prepMinutes + b.data.times.cookMinutes;
    return totalA - totalB;
  }
  
  // Default: newest (sort by publishedAt descending)
  const dateA = a.data.publishedAt?.getTime() ?? 0;
  const dateB = b.data.publishedAt?.getTime() ?? 0;
  return dateB - dateA; // newest first
});
---

<SiteLayout title="Recipes">
  <div class="page-content" data-pagefind-ignore>
    <header class="page-header">
      <h1>Recipes ({visibleRecipes.length} of {publishedRecipes.length})</h1>
      <p class="subtitle">Only the keepers. No filler.</p>
    </header>

    <RecipeFilters
      client:load
      categories={categories}
      cuisines={cuisines}
    />

    <section class="recipes-grid">
      {visibleRecipes.length > 0 ? (
        visibleRecipes.map((recipe) => {
          const slug = getRecipeSlug(recipe);
          return (
            <RecipeCard
              title={recipe.data.title}
              description={recipe.data.description}
              href={`/recipes/${slug}`}
              category={recipe.data.category}
              cuisine={recipe.data.cuisine}
              prepMinutes={recipe.data.times.prepMinutes}
              cookMinutes={recipe.data.times.cookMinutes}
              servingsDefault={recipe.data.servingsDefault}
              image={recipe.data.image}
              imageAlt={recipe.data.imageAlt}
            />
          );
        })
      ) : (
        <div class="empty-state">
          <p>No recipes found matching your filters.</p>
        </div>
      )}
    </section>
  </div>
</SiteLayout>

<style>
  .page-content {
    display: flex;
    flex-direction: column;
    gap: 2rem;
  }

  .page-header {
    padding: 1rem 0 0.5rem;
  }

  .subtitle {
    color: var(--muted);
    font-size: 1.125rem;
    margin-top: 0.5rem;
  }

  .recipes-grid {
    display: grid;
    grid-template-columns: 1fr;
    gap: 1.5rem;
  }

  @media (min-width: 640px) {
    .recipes-grid {
      grid-template-columns: repeat(2, 1fr);
    }
  }

  @media (min-width: 1024px) {
    .recipes-grid {
      grid-template-columns: repeat(3, 1fr);
    }
  }

  .empty-state {
    padding: 3rem 1.5rem;
    text-align: center;
    color: var(--muted);
  }

  .empty-state p {
    font-size: 1.125rem;
  }
</style>
